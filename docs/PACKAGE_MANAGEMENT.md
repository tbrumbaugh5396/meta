# Package Management

## Overview

The meta-repo CLI automatically detects and installs package manager dependencies (npm, pip, cargo, go) for components during `meta apply`, ensuring all required dependencies are available.

## Basic Package Management

### Purpose

Automatically detects and installs package manager dependencies for components during `meta apply`.

### Supported Package Managers

- **npm** - Detects `package.json`, runs `npm ci` (if `package-lock.json` exists) or `npm install`
- **pip** - Detects `requirements.txt` or `setup.py` or `pyproject.toml`, runs `pip install`
- **cargo** - Detects `Cargo.toml`, runs `cargo build`
- **go** - Detects `go.mod`, runs `go mod download`
- **Docker** - Detected but not installed automatically (handled separately in build step)

### Usage

Package installation happens automatically during `meta apply`:

```bash
meta apply
```

The CLI will:
1. Detect which package managers are needed for each component
2. Install dependencies in the correct order (respecting component dependencies)
3. Report success/failure for each package manager

### Skip Package Installation

To skip package installation (e.g., if dependencies are already installed):

```bash
meta apply --skip-packages
```

### Detection Logic

The CLI detects package managers by looking for specific files:

- `package.json` → npm
- `requirements.txt` or `setup.py` or `pyproject.toml` → pip
- `Cargo.toml` → cargo
- `go.mod` → go
- `Dockerfile` → docker (detected but not installed automatically)

### Example Output

```
Applying changes for component: scraper-capabilities
Detected package managers: npm, pip
Installing npm dependencies from package.json...
npm dependencies installed for components/scraper-capabilities
Installing pip dependencies from requirements.txt...
pip dependencies installed for components/scraper-capabilities
Building Bazel target: //scraper_capabilities:all
Successfully applied changes for scraper-capabilities
```

## Enhanced Package Management

### Package Lock Files

Generate package lock files for reproducible installs:

```bash
meta deps lock --component scraper-capabilities
meta deps lock --all  # Generate locks for all components
```

Generates:
- `package-lock.json` for npm
- `requirements.lock` for pip
- `Cargo.lock` for cargo
- `go.sum` for go

### Security Vulnerability Scanning

Scan dependencies for known vulnerabilities:

```bash
meta deps audit --component scraper-capabilities
meta deps audit --all
```

Scans dependencies using:
- `npm audit` for npm
- `pip-audit` or `safety` for pip

### License Compliance Checking

Check dependency licenses for compliance:

```bash
meta deps licenses --component scraper-capabilities
meta deps licenses --all
meta deps licenses --allowed "MIT,Apache-2.0,BSD-3-Clause"
```

Checks dependency licenses using:
- `license-checker` for npm
- `pip-licenses` for pip

### Dependency Graph Visualization

Generate dependency graphs for package dependencies:

```bash
meta deps graph --component scraper-capabilities --format dot --output graph.dot
meta deps graph --format json  # Component dependency graph
```

Generates dependency graphs in DOT or JSON format.

## Integration with Component Isolation

Package installation respects component isolation settings:

- **Virtual Environments** - Packages installed in component-specific venvs
- **Containers** - Packages installed in component containers
- **System-wide** - Packages installed system-wide (default)

See [Isolation and System Packages](ISOLATION_AND_SYSTEM_PACKAGES.md) for more details.

## Complete Workflow

```bash
# 1. Apply components (automatically installs packages)
meta apply --all

# 2. Generate package lock files for reproducibility
meta deps lock --all

# 3. Audit dependencies for security
meta deps audit --all

# 4. Check license compliance
meta deps licenses --all --allowed "MIT,Apache-2.0"

# 5. Visualize package dependencies
meta deps graph --component my-component --format dot --output deps.dot
```

## Implementation Details

### Files

- `meta/utils/packages.py` - Package manager detection and installation
- `meta/utils/package_locks.py` - Package lock file generation
- `meta/utils/security.py` - Vulnerability scanning
- `meta/utils/licenses.py` - License compliance checking
- `meta/utils/dependency_graph.py` - Dependency graph visualization
- `meta/commands/deps.py` - Dependency management commands

### Package Installation Process

1. Detect package managers by scanning component directory
2. For each detected package manager:
   - Check if lock file exists (prefer lock file install)
   - Install dependencies using appropriate command
   - Report success/failure
3. Continue with component build/apply

### Lock File Generation

Package lock files are generated by:
1. Running package manager's lock command
2. Capturing output lock file
3. Storing in component directory
4. Committing to version control

## Benefits

1. **Automation** - Package installation reduces manual setup steps
2. **Reproducibility** - Lock files ensure consistent installs
3. **Security** - Catch vulnerabilities early
4. **Compliance** - Ensure license compatibility
5. **Visibility** - Understand package dependency relationships

